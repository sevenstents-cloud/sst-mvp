module.exports=[66680,(a,b,c)=>{b.exports=a.x("node:crypto",()=>require("node:crypto"))},61488,a=>{"use strict";var b=a.i(66680);let c=(()=>{if("object"==typeof globalThis)return globalThis;Object.defineProperty(Object.prototype,"__GLOBALTHIS__",{get(){return this},configurable:!0});try{if("undefined"!=typeof __GLOBALTHIS__)return __GLOBALTHIS__}finally{delete Object.prototype.__GLOBALTHIS__}return"undefined"!=typeof self?self:(0,a.g)})(),d=a=>{switch(!0){case/^(?:SHA-?1|SSL3-SHA1)$/i.test(a):return"SHA1";case/^SHA(?:2?-)?224$/i.test(a):return"SHA224";case/^SHA(?:2?-)?256$/i.test(a):return"SHA256";case/^SHA(?:2?-)?384$/i.test(a):return"SHA384";case/^SHA(?:2?-)?512$/i.test(a):return"SHA512";case/^SHA3-224$/i.test(a):return"SHA3-224";case/^SHA3-256$/i.test(a):return"SHA3-256";case/^SHA3-384$/i.test(a):return"SHA3-384";case/^SHA3-512$/i.test(a):return"SHA3-512";default:throw TypeError(`Unknown hash algorithm: ${a}`)}},e="ABCDEFGHIJKLMNOPQRSTUVWXYZ234567",f=c.TextEncoder?new c.TextEncoder:null,g=c.TextDecoder?new c.TextDecoder:null;class h{static fromLatin1(a){return new h({buffer:(a=>{let b=new Uint8Array(new ArrayBuffer(a.length));for(let c=0;c<a.length;c++)b[c]=255&a.charCodeAt(c);return b})(a).buffer})}static fromUTF8(a){return new h({buffer:(a=>{if(!f)throw Error("Encoding API not available");return f.encode(a)})(a).buffer})}static fromBase32(a){return new h({buffer:(a=>{let b=(a=a.replace(/ /g,"")).length;for(;"="===a[b-1];)--b;let c=new Uint8Array(new ArrayBuffer(5*(a=(b<a.length?a.substring(0,b):a).toUpperCase()).length/8|0)),d=0,f=0,g=0;for(let b=0;b<a.length;b++){let h=e.indexOf(a[b]);if(-1===h)throw TypeError(`Invalid character found: ${a[b]}`);f=f<<5|h,(d+=5)>=8&&(d-=8,c[g++]=f>>>d)}return c})(a).buffer})}static fromHex(a){return new h({buffer:(a=>{let b=new Uint8Array(new ArrayBuffer((a=a.replace(/ /g,"")).length/2));for(let c=0;c<a.length;c+=2)b[c/2]=parseInt(a.substring(c,c+2),16);return b})(a).buffer})}get buffer(){return this.bytes.buffer}get latin1(){return Object.defineProperty(this,"latin1",{enumerable:!0,writable:!1,configurable:!1,value:(a=>{let b="";for(let c=0;c<a.length;c++)b+=String.fromCharCode(a[c]);return b})(this.bytes)}),this.latin1}get utf8(){return Object.defineProperty(this,"utf8",{enumerable:!0,writable:!1,configurable:!1,value:(a=>{if(!g)throw Error("Encoding API not available");return g.decode(a)})(this.bytes)}),this.utf8}get base32(){return Object.defineProperty(this,"base32",{enumerable:!0,writable:!1,configurable:!1,value:(a=>{let b=0,c=0,d="";for(let f=0;f<a.length;f++)for(c=c<<8|a[f],b+=8;b>=5;)d+=e[c>>>b-5&31],b-=5;return b>0&&(d+=e[c<<5-b&31]),d})(this.bytes)}),this.base32}get hex(){return Object.defineProperty(this,"hex",{enumerable:!0,writable:!1,configurable:!1,value:(a=>{let b="";for(let c=0;c<a.length;c++){let d=a[c].toString(16);1===d.length&&(b+="0"),b+=d}return b.toUpperCase()})(this.bytes)}),this.hex}constructor({buffer:a,size:d=20}={}){this.bytes=void 0===a?(a=>{if(b.randomBytes)return b.randomBytes(a);if(c.crypto?.getRandomValues)return c.crypto.getRandomValues(new Uint8Array(a));throw Error("Cryptography API not available")})(d):new Uint8Array(a),Object.defineProperty(this,"bytes",{enumerable:!0,writable:!1,configurable:!1,value:this.bytes})}}class i{static get defaults(){return{issuer:"",label:"OTPAuth",issuerInLabel:!0,algorithm:"SHA1",digits:6,counter:0,window:1}}static generate({secret:a,algorithm:d=i.defaults.algorithm,digits:e=i.defaults.digits,counter:f=i.defaults.counter}){let g=((a,d,e)=>{if(b.createHmac){let f=b.createHmac(a,c.Buffer.from(d));return f.update(c.Buffer.from(e)),f.digest()}throw Error("Missing HMAC function")})(d,a.bytes,(a=>{let b=new Uint8Array(new ArrayBuffer(8)),c=a;for(let a=7;a>=0&&0!==c;a--)b[a]=255&c,c-=b[a],c/=256;return b})(f)),h=15&g[g.byteLength-1];return(((127&g[h])<<24|(255&g[h+1])<<16|(255&g[h+2])<<8|255&g[h+3])%10**e).toString().padStart(e,"0")}generate({counter:a=this.counter++}={}){return i.generate({secret:this.secret,algorithm:this.algorithm,digits:this.digits,counter:a})}static validate({token:a,secret:d,algorithm:e,digits:f=i.defaults.digits,counter:g=i.defaults.counter,window:h=i.defaults.window}){if(a.length!==f)return null;let j=null,k=h=>{((a,d)=>{if(b.timingSafeEqual)return b.timingSafeEqual(c.Buffer.from(a),c.Buffer.from(d));{if(a.length!==d.length)throw TypeError("Input strings must have the same length");let b=-1,c=0;for(;++b<a.length;)c|=a.charCodeAt(b)^d.charCodeAt(b);return 0===c}})(a,i.generate({secret:d,algorithm:e,digits:f,counter:h}))&&(j=h-g)};k(g);for(let a=1;a<=h&&null===j&&(k(g-a),null===j)&&(k(g+a),null===j);++a);return j}validate({token:a,counter:b=this.counter,window:c}){return i.validate({token:a,secret:this.secret,algorithm:this.algorithm,digits:this.digits,counter:b,window:c})}toString(){let a=encodeURIComponent;return`otpauth://hotp/${this.issuer.length>0?this.issuerInLabel?`${a(this.issuer)}:${a(this.label)}?issuer=${a(this.issuer)}&`:`${a(this.label)}?issuer=${a(this.issuer)}&`:`${a(this.label)}?`}secret=${a(this.secret.base32)}&algorithm=${a(this.algorithm)}&digits=${a(this.digits)}&counter=${a(this.counter)}`}constructor({issuer:a=i.defaults.issuer,label:b=i.defaults.label,issuerInLabel:c=i.defaults.issuerInLabel,secret:e=new h,algorithm:f=i.defaults.algorithm,digits:g=i.defaults.digits,counter:j=i.defaults.counter}={}){this.issuer=a,this.label=b,this.issuerInLabel=c,this.secret="string"==typeof e?h.fromBase32(e):e,this.algorithm=d(f),this.digits=g,this.counter=j}}class j{static get defaults(){return{issuer:"",label:"OTPAuth",issuerInLabel:!0,algorithm:"SHA1",digits:6,period:30,window:1}}static counter({period:a=j.defaults.period,timestamp:b=Date.now()}={}){return Math.floor(b/1e3/a)}counter({timestamp:a=Date.now()}={}){return j.counter({period:this.period,timestamp:a})}static remaining({period:a=j.defaults.period,timestamp:b=Date.now()}={}){return 1e3*a-b%(1e3*a)}remaining({timestamp:a=Date.now()}={}){return j.remaining({period:this.period,timestamp:a})}static generate({secret:a,algorithm:b,digits:c,period:d=j.defaults.period,timestamp:e=Date.now()}){return i.generate({secret:a,algorithm:b,digits:c,counter:j.counter({period:d,timestamp:e})})}generate({timestamp:a=Date.now()}={}){return j.generate({secret:this.secret,algorithm:this.algorithm,digits:this.digits,period:this.period,timestamp:a})}static validate({token:a,secret:b,algorithm:c,digits:d,period:e=j.defaults.period,timestamp:f=Date.now(),window:g}){return i.validate({token:a,secret:b,algorithm:c,digits:d,counter:j.counter({period:e,timestamp:f}),window:g})}validate({token:a,timestamp:b,window:c}){return j.validate({token:a,secret:this.secret,algorithm:this.algorithm,digits:this.digits,period:this.period,timestamp:b,window:c})}toString(){let a=encodeURIComponent;return`otpauth://totp/${this.issuer.length>0?this.issuerInLabel?`${a(this.issuer)}:${a(this.label)}?issuer=${a(this.issuer)}&`:`${a(this.label)}?issuer=${a(this.issuer)}&`:`${a(this.label)}?`}secret=${a(this.secret.base32)}&algorithm=${a(this.algorithm)}&digits=${a(this.digits)}&period=${a(this.period)}`}constructor({issuer:a=j.defaults.issuer,label:b=j.defaults.label,issuerInLabel:c=j.defaults.issuerInLabel,secret:e=new h,algorithm:f=j.defaults.algorithm,digits:g=j.defaults.digits,period:i=j.defaults.period}={}){this.issuer=a,this.label=b,this.issuerInLabel=c,this.secret="string"==typeof e?h.fromBase32(e):e,this.algorithm=d(f),this.digits=g,this.period=i}}a.s(["Secret",()=>h,"TOTP",()=>j])}];

//# sourceMappingURL=%5Broot-of-the-server%5D__81bb1691._.js.map