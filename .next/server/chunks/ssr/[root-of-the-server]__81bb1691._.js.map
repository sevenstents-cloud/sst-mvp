{"version":3,"sources":["../../../../node_modules/otpauth/dist/otpauth.node.mjs"],"sourcesContent":["//! otpauth 9.4.1 | (c) Héctor Molinero Fernández | MIT | https://github.com/hectorm/otpauth\n/// <reference types=\"./otpauth.d.ts\" />\n// @ts-nocheck\nimport * as crypto from 'node:crypto';\n\n/**\n * Converts an integer to an Uint8Array.\n * @param {number} num Integer.\n * @returns {Uint8Array} Uint8Array.\n */ const uintDecode = (num)=>{\n    const buf = new ArrayBuffer(8);\n    const arr = new Uint8Array(buf);\n    let acc = num;\n    for(let i = 7; i >= 0; i--){\n        if (acc === 0) break;\n        arr[i] = acc & 255;\n        acc -= arr[i];\n        acc /= 256;\n    }\n    return arr;\n};\n\n/**\n * \"globalThis\" ponyfill.\n * @see [A horrifying globalThis polyfill in universal JavaScript](https://mathiasbynens.be/notes/globalthis)\n * @type {Object.<string, *>}\n */ const globalScope = (()=>{\n    if (typeof globalThis === \"object\") return globalThis;\n    else {\n        Object.defineProperty(Object.prototype, \"__GLOBALTHIS__\", {\n            get () {\n                return this;\n            },\n            configurable: true\n        });\n        try {\n            // @ts-expect-error\n            // eslint-disable-next-line no-undef\n            if (typeof __GLOBALTHIS__ !== \"undefined\") return __GLOBALTHIS__;\n        } finally{\n            // @ts-expect-error\n            delete Object.prototype.__GLOBALTHIS__;\n        }\n    }\n    // Still unable to determine \"globalThis\", fall back to a naive method.\n    if (typeof self !== \"undefined\") return self;\n    else if (typeof window !== \"undefined\") return window;\n    else if (typeof global !== \"undefined\") return global;\n    return undefined;\n})();\n\n/**\n * Canonicalizes a hash algorithm name.\n * @param {string} algorithm Hash algorithm name.\n * @returns {\"SHA1\"|\"SHA224\"|\"SHA256\"|\"SHA384\"|\"SHA512\"|\"SHA3-224\"|\"SHA3-256\"|\"SHA3-384\"|\"SHA3-512\"} Canonicalized hash algorithm name.\n */ const canonicalizeAlgorithm = (algorithm)=>{\n    switch(true){\n        case /^(?:SHA-?1|SSL3-SHA1)$/i.test(algorithm):\n            return \"SHA1\";\n        case /^SHA(?:2?-)?224$/i.test(algorithm):\n            return \"SHA224\";\n        case /^SHA(?:2?-)?256$/i.test(algorithm):\n            return \"SHA256\";\n        case /^SHA(?:2?-)?384$/i.test(algorithm):\n            return \"SHA384\";\n        case /^SHA(?:2?-)?512$/i.test(algorithm):\n            return \"SHA512\";\n        case /^SHA3-224$/i.test(algorithm):\n            return \"SHA3-224\";\n        case /^SHA3-256$/i.test(algorithm):\n            return \"SHA3-256\";\n        case /^SHA3-384$/i.test(algorithm):\n            return \"SHA3-384\";\n        case /^SHA3-512$/i.test(algorithm):\n            return \"SHA3-512\";\n        default:\n            throw new TypeError(`Unknown hash algorithm: ${algorithm}`);\n    }\n};\n/**\n * Calculates an HMAC digest.\n * @param {string} algorithm Algorithm.\n * @param {Uint8Array} key Key.\n * @param {Uint8Array} message Message.\n * @returns {Uint8Array} Digest.\n */ const hmacDigest = (algorithm, key, message)=>{\n    if (crypto?.createHmac) {\n        const hmac = crypto.createHmac(algorithm, globalScope.Buffer.from(key));\n        hmac.update(globalScope.Buffer.from(message));\n        return hmac.digest();\n    } else {\n        throw new Error(\"Missing HMAC function\");\n    }\n};\n\n/**\n * RFC 4648 base32 alphabet without pad.\n * @type {string}\n */ const ALPHABET = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ234567\";\n/**\n * Converts a base32 string to an Uint8Array (RFC 4648).\n * @see [LinusU/base32-decode](https://github.com/LinusU/base32-decode)\n * @param {string} str Base32 string.\n * @returns {Uint8Array} Uint8Array.\n */ const base32Decode = (str)=>{\n    // Remove spaces (although they are not allowed by the spec, some issuers add them for readability).\n    str = str.replace(/ /g, \"\");\n    // Canonicalize to all upper case and remove padding if it exists.\n    let end = str.length;\n    while(str[end - 1] === \"=\")--end;\n    str = (end < str.length ? str.substring(0, end) : str).toUpperCase();\n    const buf = new ArrayBuffer(str.length * 5 / 8 | 0);\n    const arr = new Uint8Array(buf);\n    let bits = 0;\n    let value = 0;\n    let index = 0;\n    for(let i = 0; i < str.length; i++){\n        const idx = ALPHABET.indexOf(str[i]);\n        if (idx === -1) throw new TypeError(`Invalid character found: ${str[i]}`);\n        value = value << 5 | idx;\n        bits += 5;\n        if (bits >= 8) {\n            bits -= 8;\n            arr[index++] = value >>> bits;\n        }\n    }\n    return arr;\n};\n/**\n * Converts an Uint8Array to a base32 string (RFC 4648).\n * @see [LinusU/base32-encode](https://github.com/LinusU/base32-encode)\n * @param {Uint8Array} arr Uint8Array.\n * @returns {string} Base32 string.\n */ const base32Encode = (arr)=>{\n    let bits = 0;\n    let value = 0;\n    let str = \"\";\n    for(let i = 0; i < arr.length; i++){\n        value = value << 8 | arr[i];\n        bits += 8;\n        while(bits >= 5){\n            str += ALPHABET[value >>> bits - 5 & 31];\n            bits -= 5;\n        }\n    }\n    if (bits > 0) {\n        str += ALPHABET[value << 5 - bits & 31];\n    }\n    return str;\n};\n\n/**\n * Converts a hexadecimal string to an Uint8Array.\n * @param {string} str Hexadecimal string.\n * @returns {Uint8Array} Uint8Array.\n */ const hexDecode = (str)=>{\n    // Remove spaces (although they are not allowed by the spec, some issuers add them for readability).\n    str = str.replace(/ /g, \"\");\n    const buf = new ArrayBuffer(str.length / 2);\n    const arr = new Uint8Array(buf);\n    for(let i = 0; i < str.length; i += 2){\n        arr[i / 2] = parseInt(str.substring(i, i + 2), 16);\n    }\n    return arr;\n};\n/**\n * Converts an Uint8Array to a hexadecimal string.\n * @param {Uint8Array} arr Uint8Array.\n * @returns {string} Hexadecimal string.\n */ const hexEncode = (arr)=>{\n    let str = \"\";\n    for(let i = 0; i < arr.length; i++){\n        const hex = arr[i].toString(16);\n        if (hex.length === 1) str += \"0\";\n        str += hex;\n    }\n    return str.toUpperCase();\n};\n\n/**\n * Converts a Latin-1 string to an Uint8Array.\n * @param {string} str Latin-1 string.\n * @returns {Uint8Array} Uint8Array.\n */ const latin1Decode = (str)=>{\n    const buf = new ArrayBuffer(str.length);\n    const arr = new Uint8Array(buf);\n    for(let i = 0; i < str.length; i++){\n        arr[i] = str.charCodeAt(i) & 0xff;\n    }\n    return arr;\n};\n/**\n * Converts an Uint8Array to a Latin-1 string.\n * @param {Uint8Array} arr Uint8Array.\n * @returns {string} Latin-1 string.\n */ const latin1Encode = (arr)=>{\n    let str = \"\";\n    for(let i = 0; i < arr.length; i++){\n        str += String.fromCharCode(arr[i]);\n    }\n    return str;\n};\n\n/**\n * TextEncoder instance.\n * @type {TextEncoder|null}\n */ const ENCODER = globalScope.TextEncoder ? new globalScope.TextEncoder() : null;\n/**\n * TextDecoder instance.\n * @type {TextDecoder|null}\n */ const DECODER = globalScope.TextDecoder ? new globalScope.TextDecoder() : null;\n/**\n * Converts an UTF-8 string to an Uint8Array.\n * @param {string} str String.\n * @returns {Uint8Array} Uint8Array.\n */ const utf8Decode = (str)=>{\n    if (!ENCODER) {\n        throw new Error(\"Encoding API not available\");\n    }\n    return ENCODER.encode(str);\n};\n/**\n * Converts an Uint8Array to an UTF-8 string.\n * @param {Uint8Array} arr Uint8Array.\n * @returns {string} String.\n */ const utf8Encode = (arr)=>{\n    if (!DECODER) {\n        throw new Error(\"Encoding API not available\");\n    }\n    return DECODER.decode(arr);\n};\n\n/**\n * Returns random bytes.\n * @param {number} size Size.\n * @returns {Uint8Array} Random bytes.\n */ const randomBytes = (size)=>{\n    if (crypto?.randomBytes) {\n        return crypto.randomBytes(size);\n    } else if (globalScope.crypto?.getRandomValues) {\n        return globalScope.crypto.getRandomValues(new Uint8Array(size));\n    } else {\n        throw new Error(\"Cryptography API not available\");\n    }\n};\n\n/**\n * OTP secret key.\n */ class Secret {\n    /**\n   * Converts a Latin-1 string to a Secret object.\n   * @param {string} str Latin-1 string.\n   * @returns {Secret} Secret object.\n   */ static fromLatin1(str) {\n        return new Secret({\n            buffer: latin1Decode(str).buffer\n        });\n    }\n    /**\n   * Converts an UTF-8 string to a Secret object.\n   * @param {string} str UTF-8 string.\n   * @returns {Secret} Secret object.\n   */ static fromUTF8(str) {\n        return new Secret({\n            buffer: utf8Decode(str).buffer\n        });\n    }\n    /**\n   * Converts a base32 string to a Secret object.\n   * @param {string} str Base32 string.\n   * @returns {Secret} Secret object.\n   */ static fromBase32(str) {\n        return new Secret({\n            buffer: base32Decode(str).buffer\n        });\n    }\n    /**\n   * Converts a hexadecimal string to a Secret object.\n   * @param {string} str Hexadecimal string.\n   * @returns {Secret} Secret object.\n   */ static fromHex(str) {\n        return new Secret({\n            buffer: hexDecode(str).buffer\n        });\n    }\n    /**\n   * Secret key buffer.\n   * @deprecated For backward compatibility, the \"bytes\" property should be used instead.\n   * @type {ArrayBufferLike}\n   */ get buffer() {\n        return this.bytes.buffer;\n    }\n    /**\n   * Latin-1 string representation of secret key.\n   * @type {string}\n   */ get latin1() {\n        Object.defineProperty(this, \"latin1\", {\n            enumerable: true,\n            writable: false,\n            configurable: false,\n            value: latin1Encode(this.bytes)\n        });\n        return this.latin1;\n    }\n    /**\n   * UTF-8 string representation of secret key.\n   * @type {string}\n   */ get utf8() {\n        Object.defineProperty(this, \"utf8\", {\n            enumerable: true,\n            writable: false,\n            configurable: false,\n            value: utf8Encode(this.bytes)\n        });\n        return this.utf8;\n    }\n    /**\n   * Base32 string representation of secret key.\n   * @type {string}\n   */ get base32() {\n        Object.defineProperty(this, \"base32\", {\n            enumerable: true,\n            writable: false,\n            configurable: false,\n            value: base32Encode(this.bytes)\n        });\n        return this.base32;\n    }\n    /**\n   * Hexadecimal string representation of secret key.\n   * @type {string}\n   */ get hex() {\n        Object.defineProperty(this, \"hex\", {\n            enumerable: true,\n            writable: false,\n            configurable: false,\n            value: hexEncode(this.bytes)\n        });\n        return this.hex;\n    }\n    /**\n   * Creates a secret key object.\n   * @param {Object} [config] Configuration options.\n   * @param {ArrayBufferLike} [config.buffer] Secret key buffer.\n   * @param {number} [config.size=20] Number of random bytes to generate, ignored if 'buffer' is provided.\n   */ constructor({ buffer, size = 20 } = {}){\n        /**\n     * Secret key.\n     * @type {Uint8Array}\n     * @readonly\n     */ this.bytes = typeof buffer === \"undefined\" ? randomBytes(size) : new Uint8Array(buffer);\n        // Prevent the \"bytes\" property from being modified.\n        Object.defineProperty(this, \"bytes\", {\n            enumerable: true,\n            writable: false,\n            configurable: false,\n            value: this.bytes\n        });\n    }\n}\n\n/**\n * Returns true if a is equal to b, without leaking timing information that would allow an attacker to guess one of the values.\n * @param {string} a String a.\n * @param {string} b String b.\n * @returns {boolean} Equality result.\n */ const timingSafeEqual = (a, b)=>{\n    if (crypto?.timingSafeEqual) {\n        return crypto.timingSafeEqual(globalScope.Buffer.from(a), globalScope.Buffer.from(b));\n    } else {\n        if (a.length !== b.length) {\n            throw new TypeError(\"Input strings must have the same length\");\n        }\n        let i = -1;\n        let out = 0;\n        while(++i < a.length){\n            out |= a.charCodeAt(i) ^ b.charCodeAt(i);\n        }\n        return out === 0;\n    }\n};\n\n/**\n * HOTP: An HMAC-based One-time Password Algorithm.\n * @see [RFC 4226](https://datatracker.ietf.org/doc/html/rfc4226)\n */ class HOTP {\n    /**\n   * Default configuration.\n   * @type {{\n   *   issuer: string,\n   *   label: string,\n   *   issuerInLabel: boolean,\n   *   algorithm: string,\n   *   digits: number,\n   *   counter: number\n   *   window: number\n   * }}\n   */ static get defaults() {\n        return {\n            issuer: \"\",\n            label: \"OTPAuth\",\n            issuerInLabel: true,\n            algorithm: \"SHA1\",\n            digits: 6,\n            counter: 0,\n            window: 1\n        };\n    }\n    /**\n   * Generates an HOTP token.\n   * @param {Object} config Configuration options.\n   * @param {Secret} config.secret Secret key.\n   * @param {string} [config.algorithm='SHA1'] HMAC hashing algorithm.\n   * @param {number} [config.digits=6] Token length.\n   * @param {number} [config.counter=0] Counter value.\n   * @returns {string} Token.\n   */ static generate({ secret, algorithm = HOTP.defaults.algorithm, digits = HOTP.defaults.digits, counter = HOTP.defaults.counter }) {\n        const digest = hmacDigest(algorithm, secret.bytes, uintDecode(counter));\n        const offset = digest[digest.byteLength - 1] & 15;\n        const otp = ((digest[offset] & 127) << 24 | (digest[offset + 1] & 255) << 16 | (digest[offset + 2] & 255) << 8 | digest[offset + 3] & 255) % 10 ** digits;\n        return otp.toString().padStart(digits, \"0\");\n    }\n    /**\n   * Generates an HOTP token.\n   * @param {Object} [config] Configuration options.\n   * @param {number} [config.counter=this.counter++] Counter value.\n   * @returns {string} Token.\n   */ generate({ counter = this.counter++ } = {}) {\n        return HOTP.generate({\n            secret: this.secret,\n            algorithm: this.algorithm,\n            digits: this.digits,\n            counter\n        });\n    }\n    /**\n   * Validates an HOTP token.\n   * @param {Object} config Configuration options.\n   * @param {string} config.token Token value.\n   * @param {Secret} config.secret Secret key.\n   * @param {string} [config.algorithm='SHA1'] HMAC hashing algorithm.\n   * @param {number} [config.digits=6] Token length.\n   * @param {number} [config.counter=0] Counter value.\n   * @param {number} [config.window=1] Window of counter values to test.\n   * @returns {number|null} Token delta or null if it is not found in the search window, in which case it should be considered invalid.\n   */ static validate({ token, secret, algorithm, digits = HOTP.defaults.digits, counter = HOTP.defaults.counter, window = HOTP.defaults.window }) {\n        // Return early if the token length does not match the digit number.\n        if (token.length !== digits) return null;\n        let delta = null;\n        const check = (/** @type {number} */ i)=>{\n            const generatedToken = HOTP.generate({\n                secret,\n                algorithm,\n                digits,\n                counter: i\n            });\n            if (timingSafeEqual(token, generatedToken)) {\n                delta = i - counter;\n            }\n        };\n        check(counter);\n        for(let i = 1; i <= window && delta === null; ++i){\n            check(counter - i);\n            if (delta !== null) break;\n            check(counter + i);\n            if (delta !== null) break;\n        }\n        return delta;\n    }\n    /**\n   * Validates an HOTP token.\n   * @param {Object} config Configuration options.\n   * @param {string} config.token Token value.\n   * @param {number} [config.counter=this.counter] Counter value.\n   * @param {number} [config.window=1] Window of counter values to test.\n   * @returns {number|null} Token delta or null if it is not found in the search window, in which case it should be considered invalid.\n   */ validate({ token, counter = this.counter, window }) {\n        return HOTP.validate({\n            token,\n            secret: this.secret,\n            algorithm: this.algorithm,\n            digits: this.digits,\n            counter,\n            window\n        });\n    }\n    /**\n   * Returns a Google Authenticator key URI.\n   * @returns {string} URI.\n   */ toString() {\n        const e = encodeURIComponent;\n        return \"otpauth://hotp/\" + `${this.issuer.length > 0 ? this.issuerInLabel ? `${e(this.issuer)}:${e(this.label)}?issuer=${e(this.issuer)}&` : `${e(this.label)}?issuer=${e(this.issuer)}&` : `${e(this.label)}?`}` + `secret=${e(this.secret.base32)}&` + `algorithm=${e(this.algorithm)}&` + `digits=${e(this.digits)}&` + `counter=${e(this.counter)}`;\n    }\n    /**\n   * Creates an HOTP object.\n   * @param {Object} [config] Configuration options.\n   * @param {string} [config.issuer=''] Account provider.\n   * @param {string} [config.label='OTPAuth'] Account label.\n   * @param {boolean} [config.issuerInLabel=true] Include issuer prefix in label.\n   * @param {Secret|string} [config.secret=Secret] Secret key.\n   * @param {string} [config.algorithm='SHA1'] HMAC hashing algorithm.\n   * @param {number} [config.digits=6] Token length.\n   * @param {number} [config.counter=0] Initial counter value.\n   */ constructor({ issuer = HOTP.defaults.issuer, label = HOTP.defaults.label, issuerInLabel = HOTP.defaults.issuerInLabel, secret = new Secret(), algorithm = HOTP.defaults.algorithm, digits = HOTP.defaults.digits, counter = HOTP.defaults.counter } = {}){\n        /**\n     * Account provider.\n     * @type {string}\n     */ this.issuer = issuer;\n        /**\n     * Account label.\n     * @type {string}\n     */ this.label = label;\n        /**\n     * Include issuer prefix in label.\n     * @type {boolean}\n     */ this.issuerInLabel = issuerInLabel;\n        /**\n     * Secret key.\n     * @type {Secret}\n     */ this.secret = typeof secret === \"string\" ? Secret.fromBase32(secret) : secret;\n        /**\n     * HMAC hashing algorithm.\n     * @type {string}\n     */ this.algorithm = canonicalizeAlgorithm(algorithm);\n        /**\n     * Token length.\n     * @type {number}\n     */ this.digits = digits;\n        /**\n     * Initial counter value.\n     * @type {number}\n     */ this.counter = counter;\n    }\n}\n\n/**\n * TOTP: Time-Based One-Time Password Algorithm.\n * @see [RFC 6238](https://datatracker.ietf.org/doc/html/rfc6238)\n */ class TOTP {\n    /**\n   * Default configuration.\n   * @type {{\n   *   issuer: string,\n   *   label: string,\n   *   issuerInLabel: boolean,\n   *   algorithm: string,\n   *   digits: number,\n   *   period: number\n   *   window: number\n   * }}\n   */ static get defaults() {\n        return {\n            issuer: \"\",\n            label: \"OTPAuth\",\n            issuerInLabel: true,\n            algorithm: \"SHA1\",\n            digits: 6,\n            period: 30,\n            window: 1\n        };\n    }\n    /**\n   * Calculates the counter. i.e. the number of periods since timestamp 0.\n   * @param {Object} [config] Configuration options.\n   * @param {number} [config.period=30] Token time-step duration.\n   * @param {number} [config.timestamp=Date.now] Timestamp value in milliseconds.\n   * @returns {number} Counter.\n   */ static counter({ period = TOTP.defaults.period, timestamp = Date.now() } = {}) {\n        return Math.floor(timestamp / 1000 / period);\n    }\n    /**\n   * Calculates the counter. i.e. the number of periods since timestamp 0.\n   * @param {Object} [config] Configuration options.\n   * @param {number} [config.timestamp=Date.now] Timestamp value in milliseconds.\n   * @returns {number} Counter.\n   */ counter({ timestamp = Date.now() } = {}) {\n        return TOTP.counter({\n            period: this.period,\n            timestamp\n        });\n    }\n    /**\n   * Calculates the remaining time in milliseconds until the next token is generated.\n   * @param {Object} [config] Configuration options.\n   * @param {number} [config.period=30] Token time-step duration.\n   * @param {number} [config.timestamp=Date.now] Timestamp value in milliseconds.\n   * @returns {number} counter.\n   */ static remaining({ period = TOTP.defaults.period, timestamp = Date.now() } = {}) {\n        return period * 1000 - timestamp % (period * 1000);\n    }\n    /**\n   * Calculates the remaining time in milliseconds until the next token is generated.\n   * @param {Object} [config] Configuration options.\n   * @param {number} [config.timestamp=Date.now] Timestamp value in milliseconds.\n   * @returns {number} counter.\n   */ remaining({ timestamp = Date.now() } = {}) {\n        return TOTP.remaining({\n            period: this.period,\n            timestamp\n        });\n    }\n    /**\n   * Generates a TOTP token.\n   * @param {Object} config Configuration options.\n   * @param {Secret} config.secret Secret key.\n   * @param {string} [config.algorithm='SHA1'] HMAC hashing algorithm.\n   * @param {number} [config.digits=6] Token length.\n   * @param {number} [config.period=30] Token time-step duration.\n   * @param {number} [config.timestamp=Date.now] Timestamp value in milliseconds.\n   * @returns {string} Token.\n   */ static generate({ secret, algorithm, digits, period = TOTP.defaults.period, timestamp = Date.now() }) {\n        return HOTP.generate({\n            secret,\n            algorithm,\n            digits,\n            counter: TOTP.counter({\n                period,\n                timestamp\n            })\n        });\n    }\n    /**\n   * Generates a TOTP token.\n   * @param {Object} [config] Configuration options.\n   * @param {number} [config.timestamp=Date.now] Timestamp value in milliseconds.\n   * @returns {string} Token.\n   */ generate({ timestamp = Date.now() } = {}) {\n        return TOTP.generate({\n            secret: this.secret,\n            algorithm: this.algorithm,\n            digits: this.digits,\n            period: this.period,\n            timestamp\n        });\n    }\n    /**\n   * Validates a TOTP token.\n   * @param {Object} config Configuration options.\n   * @param {string} config.token Token value.\n   * @param {Secret} config.secret Secret key.\n   * @param {string} [config.algorithm='SHA1'] HMAC hashing algorithm.\n   * @param {number} [config.digits=6] Token length.\n   * @param {number} [config.period=30] Token time-step duration.\n   * @param {number} [config.timestamp=Date.now] Timestamp value in milliseconds.\n   * @param {number} [config.window=1] Window of counter values to test.\n   * @returns {number|null} Token delta or null if it is not found in the search window, in which case it should be considered invalid.\n   */ static validate({ token, secret, algorithm, digits, period = TOTP.defaults.period, timestamp = Date.now(), window }) {\n        return HOTP.validate({\n            token,\n            secret,\n            algorithm,\n            digits,\n            counter: TOTP.counter({\n                period,\n                timestamp\n            }),\n            window\n        });\n    }\n    /**\n   * Validates a TOTP token.\n   * @param {Object} config Configuration options.\n   * @param {string} config.token Token value.\n   * @param {number} [config.timestamp=Date.now] Timestamp value in milliseconds.\n   * @param {number} [config.window=1] Window of counter values to test.\n   * @returns {number|null} Token delta or null if it is not found in the search window, in which case it should be considered invalid.\n   */ validate({ token, timestamp, window }) {\n        return TOTP.validate({\n            token,\n            secret: this.secret,\n            algorithm: this.algorithm,\n            digits: this.digits,\n            period: this.period,\n            timestamp,\n            window\n        });\n    }\n    /**\n   * Returns a Google Authenticator key URI.\n   * @returns {string} URI.\n   */ toString() {\n        const e = encodeURIComponent;\n        return \"otpauth://totp/\" + `${this.issuer.length > 0 ? this.issuerInLabel ? `${e(this.issuer)}:${e(this.label)}?issuer=${e(this.issuer)}&` : `${e(this.label)}?issuer=${e(this.issuer)}&` : `${e(this.label)}?`}` + `secret=${e(this.secret.base32)}&` + `algorithm=${e(this.algorithm)}&` + `digits=${e(this.digits)}&` + `period=${e(this.period)}`;\n    }\n    /**\n   * Creates a TOTP object.\n   * @param {Object} [config] Configuration options.\n   * @param {string} [config.issuer=''] Account provider.\n   * @param {string} [config.label='OTPAuth'] Account label.\n   * @param {boolean} [config.issuerInLabel=true] Include issuer prefix in label.\n   * @param {Secret|string} [config.secret=Secret] Secret key.\n   * @param {string} [config.algorithm='SHA1'] HMAC hashing algorithm.\n   * @param {number} [config.digits=6] Token length.\n   * @param {number} [config.period=30] Token time-step duration.\n   */ constructor({ issuer = TOTP.defaults.issuer, label = TOTP.defaults.label, issuerInLabel = TOTP.defaults.issuerInLabel, secret = new Secret(), algorithm = TOTP.defaults.algorithm, digits = TOTP.defaults.digits, period = TOTP.defaults.period } = {}){\n        /**\n     * Account provider.\n     * @type {string}\n     */ this.issuer = issuer;\n        /**\n     * Account label.\n     * @type {string}\n     */ this.label = label;\n        /**\n     * Include issuer prefix in label.\n     * @type {boolean}\n     */ this.issuerInLabel = issuerInLabel;\n        /**\n     * Secret key.\n     * @type {Secret}\n     */ this.secret = typeof secret === \"string\" ? Secret.fromBase32(secret) : secret;\n        /**\n     * HMAC hashing algorithm.\n     * @type {string}\n     */ this.algorithm = canonicalizeAlgorithm(algorithm);\n        /**\n     * Token length.\n     * @type {number}\n     */ this.digits = digits;\n        /**\n     * Token time-step duration.\n     * @type {number}\n     */ this.period = period;\n    }\n}\n\n/**\n * Key URI regex (otpauth://TYPE/[ISSUER:]LABEL?PARAMETERS).\n * @type {RegExp}\n */ const OTPURI_REGEX = /^otpauth:\\/\\/([ht]otp)\\/(.+)\\?([A-Z0-9.~_-]+=[^?&]*(?:&[A-Z0-9.~_-]+=[^?&]*)*)$/i;\n/**\n * RFC 4648 base32 alphabet with pad.\n * @type {RegExp}\n */ const SECRET_REGEX = /^[2-7A-Z]+=*$/i;\n/**\n * Regex for supported algorithms.\n * @type {RegExp}\n */ const ALGORITHM_REGEX = /^SHA(?:1|224|256|384|512|3-224|3-256|3-384|3-512)$/i;\n/**\n * Integer regex.\n * @type {RegExp}\n */ const INTEGER_REGEX = /^[+-]?\\d+$/;\n/**\n * Positive integer regex.\n * @type {RegExp}\n */ const POSITIVE_INTEGER_REGEX = /^\\+?[1-9]\\d*$/;\n/**\n * HOTP/TOTP object/string conversion.\n * @see [Key URI Format](https://github.com/google/google-authenticator/wiki/Key-Uri-Format)\n */ class URI {\n    /**\n   * Parses a Google Authenticator key URI and returns an HOTP/TOTP object.\n   * @param {string} uri Google Authenticator Key URI.\n   * @returns {HOTP|TOTP} HOTP/TOTP object.\n   */ static parse(uri) {\n        let uriGroups;\n        try {\n            uriGroups = uri.match(OTPURI_REGEX);\n        // eslint-disable-next-line no-unused-vars\n        } catch (_) {\n        /* Handled below */ }\n        if (!Array.isArray(uriGroups)) {\n            throw new URIError(\"Invalid URI format\");\n        }\n        // Extract URI groups.\n        const uriType = uriGroups[1].toLowerCase();\n        const uriLabel = uriGroups[2].split(/(?::|%3A) *(.+)/i, 2).map(decodeURIComponent);\n        /** @type {Object.<string, string>} */ const uriParams = uriGroups[3].split(\"&\").reduce((acc, cur)=>{\n            const pairArr = cur.split(/=(.*)/, 2).map(decodeURIComponent);\n            const pairKey = pairArr[0].toLowerCase();\n            const pairVal = pairArr[1];\n            /** @type {Object.<string, string>} */ const pairAcc = acc;\n            pairAcc[pairKey] = pairVal;\n            return pairAcc;\n        }, {});\n        // 'OTP' will be instantiated with 'config' argument.\n        let OTP;\n        const config = {};\n        if (uriType === \"hotp\") {\n            OTP = HOTP;\n            // Counter: required\n            if (typeof uriParams.counter !== \"undefined\" && INTEGER_REGEX.test(uriParams.counter)) {\n                config.counter = parseInt(uriParams.counter, 10);\n            } else {\n                throw new TypeError(\"Missing or invalid 'counter' parameter\");\n            }\n        } else if (uriType === \"totp\") {\n            OTP = TOTP;\n            // Period: optional\n            if (typeof uriParams.period !== \"undefined\") {\n                if (POSITIVE_INTEGER_REGEX.test(uriParams.period)) {\n                    config.period = parseInt(uriParams.period, 10);\n                } else {\n                    throw new TypeError(\"Invalid 'period' parameter\");\n                }\n            }\n        } else {\n            throw new TypeError(\"Unknown OTP type\");\n        }\n        // Label: required\n        // Issuer: optional\n        if (typeof uriParams.issuer !== \"undefined\") {\n            config.issuer = uriParams.issuer;\n        }\n        if (uriLabel.length === 2) {\n            config.label = uriLabel[1];\n            if (typeof config.issuer === \"undefined\" || config.issuer === \"\") {\n                config.issuer = uriLabel[0];\n            } else if (uriLabel[0] === \"\") {\n                config.issuerInLabel = false;\n            }\n        } else {\n            config.label = uriLabel[0];\n            if (typeof config.issuer !== \"undefined\" && config.issuer !== \"\") {\n                config.issuerInLabel = false;\n            }\n        }\n        // Secret: required\n        if (typeof uriParams.secret !== \"undefined\" && SECRET_REGEX.test(uriParams.secret)) {\n            config.secret = uriParams.secret;\n        } else {\n            throw new TypeError(\"Missing or invalid 'secret' parameter\");\n        }\n        // Algorithm: optional\n        if (typeof uriParams.algorithm !== \"undefined\") {\n            if (ALGORITHM_REGEX.test(uriParams.algorithm)) {\n                config.algorithm = uriParams.algorithm;\n            } else {\n                throw new TypeError(\"Invalid 'algorithm' parameter\");\n            }\n        }\n        // Digits: optional\n        if (typeof uriParams.digits !== \"undefined\") {\n            if (POSITIVE_INTEGER_REGEX.test(uriParams.digits)) {\n                config.digits = parseInt(uriParams.digits, 10);\n            } else {\n                throw new TypeError(\"Invalid 'digits' parameter\");\n            }\n        }\n        return new OTP(config);\n    }\n    /**\n   * Converts an HOTP/TOTP object to a Google Authenticator key URI.\n   * @param {HOTP|TOTP} otp HOTP/TOTP object.\n   * @returns {string} Google Authenticator Key URI.\n   */ static stringify(otp) {\n        if (otp instanceof HOTP || otp instanceof TOTP) {\n            return otp.toString();\n        }\n        throw new TypeError(\"Invalid 'HOTP/TOTP' object\");\n    }\n}\n\n/**\n * Library version.\n * @type {string}\n */ const version = \"9.4.1\";\n\nexport { HOTP, Secret, TOTP, URI, version };\n"],"names":[],"mappings":"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","ignoreList":[0]}